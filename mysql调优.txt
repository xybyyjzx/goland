客户端

  
服务端  连接器 分析器（词法分析 语法分析） 优化器（ｒｂｏ规则优化　ｃｂｏ成本优化）
执行器　和存储引擎　　　　　　

减少ｉｏ　８　之前有缓存　（数据变更频繁导致缓存命中低　８之后废弃了）

  
存储引擎

性能监控工具
ｓｈｏｗ　ｐｒｏｆｉｌｅ　工具

ｓｅｔ　ｐｒｏｆｉｌｉｎｇ　＝　１　
查看ｓｑｌ　各个步骤执行时间　也可以查看消耗的系统资源　ｃｐｕ　ｉｏ　等
之后可能废弃　不推荐
推荐另一个　ｓｃｈｅｍａ　默认是开启的　　
ｓｈｏｗ　ｄａｔａｂａｓｅｓ　中有一个ｓｃｈｅｍａ数据库　其中有很多表


ｓｈｏｗ　ｐｒｏｃｅｓｓｌｉｓｔ　监控数据库连接
可以杀掉连接
数据库连接池　德鲁伊　性能监控　

ｓｃｈｅｍａ　与数据类型优化
更小的通常更高　　更小的数据类型　
简单就好
ｉｐ地址最好用整型　有一个函数可以转换　ｉｎｅｔ＿ａｔｏｎ（＇１９２．１６８．１．１＇）
ｉｎｅｔ＿ｎｔｏａ（＇３３３３３３２１５６６＇）
整型视觉效果不明显
尽量避免使用ｎｕｌｌ　能不使用尽量不使用　其优化统计　值比较　复杂　可使用＇＇空字符串
整型　8　16　34　64　位　
字符　字符串选择　
ｃｈａｒ　最大长度255　会自动删除末尾空格　写效率高于ｖａｒｃｈａｒ　以空间换时间　
	存储长度波动不大的数据　如ｍｄ５数据　短字符串　经常更新的字符串
ｖａｒｃｈａｒ　：　可变长度　磁盘页４ｋｂ　内存都是读页
ｂｌｏｂ　ｔｅｘｔ　用得少　一般都是存文件　保存路径
时间类型　：
ｔｉｍｅ　：
ｄａｔａｔｉｍｅ：8个字符　时区无关　保存到毫秒　有日期函数
ｔｉｍｅｓｔａｍｐ　：　占用4个子节　1970、1、1　2038.01．19　依赖时区
ｄａｔｅ　：占用三个子节　比其他占用少　ｄａｔｅ时间日期函数转换　1000.0.0　9999.12.31
ｔｉｍｅｓｔａｍｐ　用得比较多
使用枚举代替字符串类型　ｍｙｓｑｌ　会压缩枚举类型　底层存储整型　有对应的文件做转换
	还可进行排序　与定义表的顺序有关系　尽量不要用数值
特殊类型　ｉｐ地址　
类型设计的好　长度设计　表空间占用得少　ｉｎｔ的长度




schema与数据类型优化 
   	数据类型优化
	合理使用范式和反范式	减少数据冗余 会增加关联 减少使用join 
				大宽表避免冗余
	范式 和 反范式 混合使用     排序的需要 避免全排序
	列不可分 不能传递依赖 直接依赖主键


	主键选择      代理主键 与业务无关的 无意义的 自增主键
	自然主键      事物属性中的自然唯一标识
	推荐使用代理主键         他们不与业务耦合  更容易维护  全部表
	字符集选择  utf8-mb4 utf8只能存两个字节的
	mysql 能对字段字符设计  没必要utf8就用 latin1 拉丁 减少空间 	   减少io 
存储引擎的选择    默认 innodb   myisam   innodb 默认是给索引加锁 是的话就是行锁 不是的话就是表锁
	myisam 适合 大量select 
	适当的数据冗余     减少io 以空间换取时间
	适当拆分 ： 当表中存在 text 或者大字段时 将其拆分到另外的表中



执行计划 ： explain 
id  当前sql 的执行顺序 值越大越先执行 id相同 从上到下
select_type   查询类型 子查询 联合查询 普通查询
table 表名
type 访问类型  全表 all index range index_subquery  unique_subquery index_merge ref_or_null  ref eg_ref const system      type 出现all 需要优化了 优化到range 最低  范围查询  重要的衡量级别
possible_keys  可能使用的索引
key	实际使用的索引
key_len  length
ref 索引那一列使用了
rows 可能的数据量
extra using filesort 全文件排序  索引排序 是否覆盖索引 连接缓存 

索引 B+树
hash表 数组加链表 存在问题 ？ 都要加载到内存  消耗内存 必须要等值判断 对范围支持不好
memary 的索引格式时hash  
二叉树 极端情况下 数据倾斜 退化为链表 增加节点 就会增加io
bst tree
avl tree 平衡树    需要旋转操作 最短子树 最大子树 高度不能超过1 数据多了 旋转多 写操作低 读快
红黑树   最长子树不超过子树 两倍即可 减少旋转操作 旋转变色 提升写 减少读 avl树变化
	节点都会增加 就会增加io 因为子节点只有两个
B树 增加节点分支树 一次读取16k 一条1k 3 层 5000多条
B+树    不存data  b+树在B树的基础上进行优化 1000 * 1000 * 16 三层即可支撑千万级别数据
	叶子节点中存在链表 指向后面一个节点 增加范围查询效率
b*树 在非叶子节点中也增加了连接
innodb 存的是整行数据 聚簇索引  一个索引就是一个树 一般是三层 mysql 速度是很快的  卡在io和并发缓存 8取消缓存 因为缓存命中低
myisam 存的数据地址 数据分开存储 非聚簇索引  
mysql 会自建主键 非空唯一字段 自建rowid


索引的优点 大大减少需要扫描的行数 帮助服务器避免排序和临时表 将随机io变成顺序io 
索引的用处 快速查找匹配where子句的行  如果能在多个索引中选择 会选最少行的索引
	 多列会会使用最左前缀优化  连接时从其他表中检索行数据 查找特定列的min 或 max 值
	 如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组
	在某些情况下 可以优化查询以检索值而无需查询数据行 
索引的分类  主键索引 唯一索引 普通索引 全文索引 组合索引 数据库会给唯一键建索引    
	   回表 ：普通列的索引不是存的整行数据 是存的主键 先查一个B+树 再查询主键B+树
                  覆盖索引 ：回表会便利两个B+树  如果只需要id  则不会去查询主键B+树   select id from   
	  最左匹配 :  组合索引中 最左侧的列 会走索引 
	  索引下推 ： 组合索引 name age where name  = and age =      再取数据的时候就过滤了 再存储引擎层     取name 的时候就把age过滤了
索引采用的数据结构 哈希表 B+树













	
	

































